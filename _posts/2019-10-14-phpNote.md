---
title: PHP笔记
teaser: 个人使用笔记，并不规范，仅供参考！
category: php
---

## 基础

1. php是什么
    术语：超文本预处理器
      	用一句话概括：一种开发动态网站的服务器脚本语言

2. php文件存放位置

   ​        wampserver环境的根目录         www目录
   ​	phpstudy环境的根目录		www目录
   ​	xampp环境的根目录			htdocs目录
   ​	apache原生环境的根目录		htdocs目录

3. 如何运行php文件
       开启集成环境
        打开浏览器
        地址栏输入localhost
        点击需要运行的php文件
   注意：若目录下拥有index.php或者index.html文件，那么在打开该文件夹时还自动访问index文件

4. 定界符
       \<?php

   ​              ?\>
   ​	注意php代码只有在定界符内才能正常运行，负责原样输出
   ​	在定界符之外是可以直接书写html代码的
   ​	再定界符之内只有通过echo 来输出内容

5. 常用输出

   ​	echo “内容”
   注意：
   ​	内容可以是数字，字母，标点符号，汉字，html代码
   ​	若内容是纯数字可以不写引号
   ​	若php定界符中只有一个echo则可以简写为\<?= '内容'?\>

6. php字符集/编码

   ​	header("content-type:text/html;charset=UTF-8");

7. 注释

   ​	单行注释   //  或者#
   ​	多行注释  /**/

8. 基本语法

   ​	每一条命令均以;号结尾
   ​	最后一条命令可以省略分号

9. 查看php环境

   ​	phpinfo();

## 变量

1. 变量：一个存储任意数据的变量

2. 格式：

   ​	$变量名 = 值

3. 注意点：

   1. 变量名前面一定要加$符
   2. 变量名由数字、字母、下划线组成；但是不能以数字开头
   3. 变量名是区分大小写的
   4. 没有值的变量都会认为是未定义的变量

4. 变量技巧

   1. 可变变量：将一个变量的值 作为另一个变量的名去使用
       例如：
         		$name = 'abc';
         		$abc = '123';
         		echo $$name    输出的结果为123
   2. 传值：让一个变量的值等于另一个变量的值
             例如：
                       $a = 100;
                        $b = $a;
                         $b = 200;
                         echo $b； 输出结果为200
                         echo $a； 输出结果为100
   3. 传址：把一个变量的值的存储地址让给另一个变量
             例如：
                       $a = 100;
                       $b = &$a;
                       $b = 200;                   
                       echo $a;   输出结果为200
                       echo $b;   输出的结果为200

   ## 常量

   定义：经常不变的量

   格式：

   ​	const	常量名 = 常量值

   ​	define（常量名，常量值，bool）
   ​							true 	不区分大小写
   ​							false	区分大小写  默认

   注意点：

   ​	1、严格区分大小写

   ​	2、常量不能重新赋值

   ​	3、常量不能重新定义

   预定义常量

   ​	PHP_INT_MAX		最大整型

   ​	M_PI				圆周率

   ​	PHP_VERSION		php当前版本

   ​	PHP_OS				php的所在的操作系统

   魔术常量

   ​	\_\_FILE__		获取盘符地址
   ​	\_\_DIR__		获取当前目录
   ​	\_\_LINE__		获取行号

## 进制转换

|          |   基数    | 前缀 |
| :------: | :-------: | :--: |
|  二进制  |    0-1    |  0b  |
|  八进制  |    0-7    |  0   |
|  十进制  |    0-9    |  无  |
| 十六进制 | 0-9 + a-f |  0x  |

任意进制转换为十进制公式：基数 * 进制数^开次方
						个位开0次方
						十位开1次方
						百位开2次方
						千位开3次方
						以此类推......

十进制转换为任意进制：将十进制的数 除以 进制数  倒取余数

## 数据类型

### 标量类型

#### 整型	

int    所有的整数
最大值：PHP_INT_MAX  来获取
  		echo  PHP_INT_MAX；
  		php7.0-  	最大值为21亿
  		PHP7.0+		最大值为	9223372036854775807
  	is_int()函数来判断是否为int数据类型

#### 浮点型    

 float     所有的小数
    值得写法：所有的小数
                       科学计数法 xEy 表示x乘以10的y次方

​	通过is_float()函数来检测是否为浮点数

有效位数：
		从左往右，第一个非零数字开始计算，一共14位
浮点运算：
		浮点数在转换为二进制时时不精确的
		不要用浮点数左等价运算，因为在计算机中0.1+0.2 !=  0.3.

#### 布尔型                 

bool

​	值得写法：
​			true
​			false      两种极端的状态

​	作用
​		当无法用数值来表达时，可以用状态来表示
​		常用于 比较和判断等场合

​	通过is_bool()函数来判断是否为布尔型

​	等价值：
​		有七种值是于false等价，其余都与true等价
​		1.false
​		2.0
​		3.0.0
​		4.''和‘0’ 	空字符串和零字符串
​		5.[]		空数组
​		6.null	空数据类型
​		7.未定义的变量

#### 字符串类型

​	值得写法：
​		单引号
​		双引号
​		heredoc结构

​	heredoc结构写法
​		<<<开始定界符



​		结束定界符；
​	注意：

​		heredoc开始定界符后面不能有任何字符，包括空格
​		 heredoc结束定界符前后都不能有任意字符，包括空格
​		开始定界符必须和结束定界符一致
​		最大长度2G

​	通过is_string()函数来判断是否为字符串类型

​	通过is_scalar()函数来检查是否为标量

​	通过is_numeric()来判断是否为数字字符串
​			只有数字or只包含数字的字符串都是

单双引号的区别：

​			单引号：不解析变量和转义字符，速度快

​			双引号	解析变量和转义字符，速度慢

单引号和双引号的共同特性：支持互插，不能自插。

### 复合类型

#### 数组类型

array  数组

定义：一个可以容纳多个数据的容器

分类：

* 索引数组：键为整型(int)
* 关联数组：键为字符串类型(string)
* 混合数组​：键既有整型，又有字符串型

形式：

​	$变量名[键名] = 变量值

​	$变量名 = [键1 = > 值1，键2 => 值2，键3 => 值3]

​	键值对：只要有一个键，就有一个值，没有键就没有值

输出数组：

​	var_dump(数组)

​	print_r(数组)

数组形成

​	array（

​		键  =>  值
​		键  =>  值
​		键  =>  值

​	）

键：

​	键的别名：索引，下标，偏移量。

​	键的类型：int  或 string

​	*数组不写键名是，默认的键为从零开始，依次替增
​	*部分键指定，空键会从已有的最大整型键加一
​	*等价键
​		'纯数字字符串' = 纯数字
​		false = 0=0.0='0'=00x
​		ture = 1 =1.0 = '1' = 1.x
​		null = ' ' = 未定义变量
​	*键不能重复，一旦重复，后面的会覆盖前面的

值：

​	值的类型：任意类型

##### 多维数组

​	多维数组：数组中嵌套数组

​	一维：
​		array
​			array => 值

​	二维
​		array
​			键1  => array1,
​			键2  => array2,
​			键3  => array3,

​	三维
​		array
​			键  => array
​					键  =>  array

$array\[]\[]\[]调用三维函数的值

##### 字符串数组

字符串在一定意义上可以当做索引数组来操作

* 数字，字母，标点占一个字节，读取也是一个一个的读取
* 汉字占三个字节，必须连续输出3个才能读取一个汉字，并且顺序不能颠倒
* 当索引超出范围时返回的是空字符串

#### 对象

定义：一切皆为对象

获取对象：

​	变量 = new stdClass

检测是否为变量：is_object(变量名);

### 特殊类型

#### 资源

定义：所有的文件都是资源

获取资源

​	变量 = fopen（'文件地址','r'）;

检测是否为资源：is_resource();

#### 空数据类型

值得写法：null

作用：占位

有三种情况的值直接显示为null

​	1.直接赋值为null的变量
​	2.未定义的变量
​	3.被删除的变量        unset()：删除数据

### 数据类型的转换

#### 自动转换

​	算数运算符可以让布尔类型和字符串类型的数据转换为整型或者浮点型

#### 强制转换

##### 临时转换

1. (要转换的类型)变量：
   		类型支持：int	float	bool	string	array	object	

2. 通过函数来进行临时转换

   intval(变量)				转换为整型
   boolval(变量)				转换为布尔型
   floatval(变量)				转换为浮点型
   strval(变量)				转换为字符串型

##### 永久转换

​	settype(变量，‘类型’)；

## 运算符

### 算数运算符

 算数预算符有：+ - \* / % ++ --

%取模的结果正负取决于除数的正负

%取模结果的范围

​		结果范围 0  ~ n		%(n+1)
​		结果范围 m ~ n		%(n-m+1) + m

a++		先返回值，再++；	a--	先返回值，再--
++a		先++，再返回值；	--a	先--，再返回值

### 拼接运算符

拼接运算符：小数点（英文）

作用：拼接变量与变量；拼接变量与字符串

### 赋值运算符

赋值运算符有：=   +=   -+    *=     /=     %=      .=

= 	先算等号右边的，再算等号左边的

​	等号左边不能做运算

+=           a += b 	==>		a = a+b

-+	-=	\*=	/=	%=	.=   于上同理

### 比较运算符

所有的比较结果都是 bool

​			<  <= 
 			>  >=
 			 ==   		两边的值相等
​			===     		两边的值相等，并且数据类型也一致	（全等）	
​			!=    			两边的值不相等
​			!==			只有全等时为true，其余都为false

### 逻辑运算符

|        |    符号    |            运算规则            |
| :----: | :--------: | :----------------------------: |
| 逻辑与 | && 或 and  | 两边为真即为真，一边为假即为假 |
| 逻辑或 | \|\| 或 or | 一边为真即为真，两边为假即为假 |
| 逻辑非 |     ！     |       真既是假，假即是真       |

注意点：

* 纯逻辑运算：先算与，再算或
* 赋值逻辑运算：画方框 
* 单词逻辑的与或的优先级要比 = 低

### 三元运算符

表达式？ true环境：false环境；

## PHP中常用输出方式

1. echo
   * 支持类型：int，string，float，resource;
   * 语法结构
   * 可以输出多个变量，用逗号隔开；
   * 多用于普通输出一行
2. print
   * 支持类型：int，string，float，resource；
   * 语法结构
   * 只能输出一个变量
3. print_r
   * 支持类型：int，float，string，array，object，resource；
   * 函数
   * 数组打印数量，理论上无上限，实际受内存限制；
   * 适合大量数据输出
4. var_dump
   * 支持所有类型
   * 函数
   * 数组打印上限为128个
   * 常用于测试查看详情信息

## 基本函数

empty()
	检测一个变量是否为空
	为空时返回true   （只要与false等价，即为空）
	非空时返回false

isset()
	检测一个变量是否设置
	设置则返回true
	未设置则返回false （值等于null，即为未设置）

unset()
	删除一个变量

key()		获取当前指针所指向的键，获取之后不会向下移

current()		获取当前指针所指向的值，获取之后不会向下移

next()		指针向下移一位，当指针超出范围时键为null，值为false

prev()		指针向上移一位

reset()		指针返回至第一位

end()		指针返回至最后一位

each()		获取当前指针的键和值，并且指针向下移一位，在PHP7中已弃用

strlen()		获取字符串长度

array_merge()	将一个或者多个数组合并为一个数组

array_combine()	将两个数组合并为一个数组,其中一个数组的值为键,另一个值为值

explode()	将一个字符串打散为数组,以第二个参数作为分隔符

implode()	数组转换为字符串	

## 流程控制

### 顺序结构

代码通过从上往下依次执行，就是顺序结构

### 分支结构

#### if语句

​	单向分支：
​			if(条件表达式)  1行代码块；
​			if（条件表达式）{

​				代码块；
​			}

​	多向分支：
​			if(条件表打式1){

​				true环境1；
​			}elseif(条件表打式2){

​				true环境2；
​			}else{

​				false环境；
​			}
​			

​	巢状分支：
​			if(条件表打式1){

​				if(条件表打式2){

​					true环境；
​				}else{

​					false环境；	
​				}

​			}else{

​				false环境；
​			}

条件表打式：只看最终结果是否为true或者false；

代码块:可0行，可一行，可多行。

if分支适合范围型判断，也可以用于定值判断

#### switch语句

switch   分支适合用于定值判断

switch(标志){

​		case 标志1：
​				代码块；
​				break；

​		case 标志2：
​				代码块；
​				break；
​			......
​		default:
​				代码块；

}

一旦执行到break时，立马跳出switch分支

匹配不到标志是，则执行default区域

### 循环

循环三要素：

​		1.初始值
​		2.循环条件
​		3.循环增量

#### while循环

先判断再循环

   初始值

while（循环条件）{

​		代码块（增量）
}

#### dowhile循环

先执行一次代码，在判断

初始值

do{

​	代码块(增量)
}while(循环条件);

#### for循环

for(初始值;循环条件;循环增量){

​	代码块；

}

效率：while和do while的执行效率高，for比较方便

注意：
	循环条件最终结果为true时，才认为条件成立

条件可能是：赋值，比较，逻辑。

#### foreach循环

​	foreach(数组名  as   键  =>   值){

​		代码块

​	}

​	如不需要键时则省略如下

​	foreach(数组名   as   值){

​		代码块

​	}

## for、if与HTML的混合写法

for:

​	\<?php for(): ?>

​		html代码

​	\<?php enfor ?>

if:

​	\<?php if():  ?>

​		html代码（true环境1）

​	\<?php elseif(): ?>

​		HTML代码块（true环境2）

​	\<?php endif?>

## 函数

### 定义函数

作用：将一段代码组装成一个完整的功能

分类：
	内置函数：PHP官方开发组实现的
	自定义函数：由自己根据需求开发一个功能

自定义函数：

​	function   函数名( 参数（形参）)
​	{	

​		代码块；

​	}

函数名(  参数 （实参）  )；     =>     调用函数

注意：
	*函数不调用是不会执行的
	*不调用函数依旧会执行函数里面的语法
	*定义函数和调用函数的位置不分先后顺序
	*函数可以互相调用

函数名：

1. 由数字，字母和下划线组成，但不能以数字开头
2. 函数名不区分大小写
3. 命名方式
   * 驼峰式：从第二个单词开始，首字母大写
   * 帕斯卡：每个单词首字母都大写
   * 匈牙利：每个单词之间用下划线隔开
4. 函数名不能重复
5. 函数名取得要有意义，并且简单明了。

### return

作用：立马中断函数，并且将值带会到调用函数的地方

返回类型：返回任意类型

如果需要一次性返回多个值可将多个值储存在一个数组里面，并返回该数组。

函数return什么就返回什么。	

### 函数参数

​	参数分类：

​		形参：定义函数时给的参数   param       parameter
​		实参：调用函数时给的参数  arg		    argument

​	参数数量：

​		实参个数 == 形参个数
​			参数依照先后顺序接收。

​		实参个数 > 形参个数
​			参数依旧按照先后顺序接收，多余的实参都被舍弃	

​		实参个数 < 形参个数
​			参数依旧按照先后顺序接收，多余的形参在php5中被当做未定义的变量来处理，在PHP7中多余的参数会直接报错，中断程序。

​		实参个数不确定时
​			func_num_args();   => 获取参数的总个数
​			func_get_args();	=> 以数组的形式返回所有的实参  
​			func_get_arg(n);	=> 返回下标为n的实参值

​		形参默认值
​			实参个数小于形参时，多余的形参可以采用默认值的方法来给形参赋值
​	例如：fuction   demo( $n1,$n2,$n3=100 ){}

### 函数技巧

 1. 可变函数：将一个变量的值，当做另个函数名来使用
    	例：
        		function  demo(){}
        		$a = 'demo';
        		$a()  =>  可以正常调用demo函数

 2. 引用函数
       例：
                function  demo( $n )
                {
                     $n = 100;    echo $n;  
                }

    ​                $a = 200;
    ​		demo($a);   此时$a的值已经变成100，因为变量$a的储存地址传给了demo函数得形参，所以在函数内改变形参的值时，$a的值也一起改变了。

    ### 递归函数

    自己调用自己,最终有一个结束条件

### 变量的作用域

1. 全局变量：在函数之外定义的变量，即为全局变量

2. 局部变量：在函数之内的变量，即为局部变量

3. 静态变量：比较特殊的局部变量，在函数结束时，不会立即从内存中消失，当再次调用函数时，静态变量不会重新初始化，而是直接使用上一次对的静态值

   特性：
   	全局变量不能直接在局部环境中使用
   	局部变量不能在全局环境中使用
   	在局部环境中，全局变量通过$GLOBALS['变量名']超全局数组，可以在局部环境中使用
   	在局部环境中，局部变量通过global 定义为全局变量，之后就可以在全局变量中使用

   注意点：
   	所有的普通全局变量，是可以在全局环境中任意使用
   	函数一旦定义，就会形成局部作用域，函数内所定义的变量，一旦脱离局部作用域，就会立马从内存中消失
   	函数一旦结束，里面所定义的变量也会立马从内存中消失

## 预定义数组变量

$GLOBALS	超全局变量数组

$_GET		接收以get方式提交的内容

$_POST		接收以post方式提交的内容

$_REQUEST	接收所有以pot get cookie  方式提交的内容

$_FILES		专门用于接收所传过来的文件

$_COOKIE	储存浏览器里面的cookie

$_SESSTION	储存服务器里面的session

$_SERVER	含有了主机，IP，参数，脚本信息，终端浏览器版本
			HTTP_HOST			获取主机地址
			HTTP_USER_AGENT	终端浏览器版本
			HTTP_REFERER		获取上一级地址来源
			REMOT_ADDR		获取IP地址
			REQUEST_METHOD	请求方式
			QUERY_STRING		请求参数
			REQUEST_URI		请求地址
			SCRIPT_NAME		当前脚本根目录
			SCRIPT_FILENAME	当前脚本盘符目录

## 正则表达式语法

定界符：

​	表示一个正则表达式的开始和结束
​			1./ 	/
​			2.#	#
​			3.{	}

原子：
	可见原子：Unicode编码表中键盘输出后肉眼可见的字符
		有哪些：
			*标点  “   ‘  _      ？   .    等等
			*英文，字母，数字，a-z,A-Z,0-9
			*汉字，日文，阿拉伯文等其他语言文字
			*Σ θ ∈ ≌ 等数理化公式符号
			*其他可见字符

​		不可见原子：Unicode编码表中键盘输出后肉眼看不见的字符
​			有哪些：
​				*换行符    \n
​				*回车	  \r
​				*制表符	  \t
​				*空格
​				*其他不可见字符

元字符：
	原子的筛选方式
		|	匹配两个或多个分支选择
		[]	匹配方括号中的任意一个原子
		[^]	匹配除了方括号中的原子之外的任意字符

​	原子的集合：将某一类原子进行归类，简化正则的书写

​		.	匹配除换行符外的任意字符
​		\d	匹配任意一个十进制数字，即\[0-9];
​		\D	匹配除了十进制以外的任意字符，即\[^0-9]
​		\s	匹配一个不可见原子，即\[\n\t\r]
​		\S	匹配一个除了可见原子，即\[^\n\t\r]
​		\w	匹配任意一个数字、字母或下划线，即[0-9a-zA-z_]
​		\W	匹配任意一个非数字，字母或下划线，即[^_0-9a-zA-Z]

​	量词：查找字符串中某个原子连续出现多少次
​		{n}	表示其前面的原子恰好出现n次
​		{n,}	表示其前面的原子最少出现n次
​		{n,m}表示其前面的原子最少出现n次，最后出现m次
​		*匹配0次，1次或者更多次其前面的原子，即{0,}
​		+匹配1次或者多次其前面的原子，即{1,}
​		?匹配0次或者1次其前面的原子，即{0,1}

​	边界控制：模式单元和模式选择
​		^	匹配字符串开始的位置
​		$	匹配字符串结尾的外置
​		()	匹配其中的整体为一个原子
​		(|)	匹配其中的两个或更多的选择之一，分割多选之一

​	模式修正符
​		贪婪匹配
​				.*	匹配结果存在歧义时取其长(默认)
​		懒惰匹配
​				.*?	匹配结果存在歧义时取其短
​				U	贪婪 — 懒惰切换
​		忽略空白
​				x	匹配结果忽略空白
​		大小写匹配
​				i	匹配结果忽略字母大小写

​				u	把汉字当成一个字符长度

1.单次匹配
	preg_match(正则表达式，内容，[匹配结果])

​		返回值：匹配的次数
​				成功：1
​				失败：0

2. 全部匹配
   preg_match_all(正则表达式，内容，[匹配结果])
   	返回值：匹配的次数
   			成功：>1
   			失败：0

正则替换：

​	函数：preg_replace(正则，替换值，内容)

​	返回值：替换之后的内容

正则分组：模式单元

​		  在匹配结果中，下标为0，就是整个正则匹配的结果
​						下标为1，就是第一个组匹配的结果
​						下标为2，就是第二个人组匹配的结果
​						以此类推

后向引用：	

​		后面的元素引用前面的，保证两处的值一致
​		\1会与第一个组匹配的结果一致
​		\2会与第二个组匹配的结果一致
​		以此类推

取消分组：

​		（?: 正则）	该小括号不会参与正则分组

正则过滤：
		函数：preg_grep(正则，数组)
		返回值：过滤之后的数组

## 时间

Unix时间戳		单位s

获取当前时间戳

​	time()	1970~现在的秒数
格式化时间戳：date(格式，时间戳)

​	格式的写法：
​			非字母都是原样输出的·
​			字母区分大小写
​			Y	4位年份  year
​			y	2位年份
​			m	月份	month
​			d	天		day
​			H	24小时  hour	
​			h	12小时 
​			a	am/pm
​			i	分	minute
​			s	秒	second

时区

​	默认时区：UTC  世界标准时间，格林威治
​	中国时区：PRC

​	date_default_timezone_get();	获取时区
​	date_default_timezone_set();	设置时区

创建一个时间点
	mktime(时,分,秒,月,日,年);
	返回值:时间戳

字符串转时间
	strtotime(字符串);
	返回值:时间戳
	例:
		strtotime('-1 day')  =>  表示昨天

睡眠时间:
	sleep(int)  => 延迟多少秒执行脚本

微秒
	microtime(true)  => 以微秒的方式显示时间

## 错误处理

php程序错误一般发生在一下3种情况:

### 语法错误

​	最常见,也是最容易修复的
​	组织脚本的执行

### 运行错误

​        比较常见,比较容易修复
​         阻止脚本的执行,也有不阻止脚本的执行

错误种类:

1.error			致命错误,组织脚本执行

2.warning		警告错误,不会阻止脚本的执行

4.parse                   语法错误

8.notice			提示错误,不会阻止脚本运行

### 逻辑错误

​        最麻烦,也不容易修复
​	不会报错,也不会阻止脚本的执行

### 屏蔽错误

目的:
	项目测试/开发中,所有的错误都必须正常显示
	项目上限后,屏蔽所有的错误

屏蔽1:
	错误抑制符	@
	哪报错,就在那用@符来屏蔽错误,屏蔽范围非常小

屏蔽2:
	函数 error_reporting(参数)   (推荐使用)
	从调用该函数之后,产生屏蔽错误的效果,所以该函数的位置一般在头部
	作用域:当前文件
	参数:
		0			屏蔽所有错误
		E_ALL		显示所有的错误
		E_WARNING	屏蔽warning级错误
		E_NOTICE	屏蔽notice级文件
		E_ALL  ^E_WARNING	显示除warning外的所有错误
		E_ALL & ~E_WARNING	显示除warning外的所有错误
		E_ALL ^E_NOTICE		显示除notice外的所有错误
		E_ALL & ~E_NTICE	显示除notice外的所有错误

屏蔽3:
	函数  ini_set()		临时修改配置文件
	作用域:当前文件
	配置:
		display_errors = On/1		开启错误提示
					      Off/0		关闭错误提示
		error_reporning = 值  与屏蔽2的常量参数一致

屏蔽4:
	修改配置文件 php.ini
	作用域:整个服务器,慎用
	位置:	wamp/bin/apache/apachex.x.x/bin/php.ini
	配置:
		display_errors = On/Off
		error_reporting = 常量
	注意:
		修改任意的配置文件,只有在重启服务后,才能起作用
		配置文件以分号开头,代表注释,一般不需改动

### 自定义错误

​	strigger_error(报错信息,错误类型)
​						  E_USER_WARNING	自定义致命错误
​						  E_USER_NOTICE		自定义提示错误
​						  E_USER_ERROR		自定义提示错误

### 错误日志

​	error_log(s1,s2,s3)
​	参数:
​		s1:报错信息
​		s2:错误处理类型	3(写日志)
​		s3:目标文件

逻辑错误
最麻烦的地方:既不报错,又不会终止脚本的执行

如何缩小错误范围
	1.断点法:通过die主动终止程序,并且在die之前输出相关的数据,从而判断
	2.注释法:利用注释不被解析得特性来判断

## 文件

### 文件处理

1. 文件分类
   文件 	file
   文件夹	dir
2. 获取文件的类型
    函数:filetype()
      	返回值:file或者dir
3. 获取文件的大小
          函数:filesize()
           返回值:文件的大小,单位B
           注意:filesize()不能获取目录的大小
4. 检测文件是否存在
          函数:file_exists();
          返回值:bool
5. 检测文件的创建时间
          函数:filectime()
           返回值:时间戳
6. 检测文件的修改时间
          函数:filemtime()
          返回值:时间戳
7. 检测文件的上次访问时间
          函数:fileatime()
          返回值:时间戳
8. 检测文件是否可读
          函数:is_readable()
          返回值:bool
9. 检测文件是否可写
          函数:is_writeable()
          返回值:bool
10. 获取文件的目录路径
                函数:dirname()
11. 获取文件的文件名
                函数:basename()
12. 解析盘符式路径
                 函数:pathinfor()
                 返回值:array
13. 解析网址式路径
                  函数:parse_url
                  返回值:array
14. 打开一个目录
                   函数:opendir()
                   返回一个资源
15. 读取一个资源
                    函数:readdir()
                    返回资源名
16. 关闭一个资源
                  函数:closedir()
17. 检测是否为文件
                 函数:is_file()
                  返回值:bool
18. 检测是否为目录
                  函数:is_dir()
                  返回值:bool
19. 复制文件
               函数:copy(参数1,参数2)
               参数1:复制谁
               参数2:复制到哪去
20. 剪切文件
               函数:rename(参数1,参数2);
               参数1:剪切谁
              参数2:剪切到哪去
             注意:换个目录是剪切,不换目录是重命名
21. 创建文件
              函数:touch('文件名地址')
22. 删除文件
              函数:unlink('文件地址')
23. 创建目录
              函数:mkdir('目录地址') => 创建单层目录
                       mkdir('目录地址',0777,true)  =>    创建多层目录       
24. 删除目录
              函数:rmdir('目录地址')
              注意:只能删除空目录
25. 向文件赋予内容
              函数:file_put_contents('文件地址','内容')
              先将文件大小截为零,再重新写入内容
26. 向文件获取内容
              函数:file_get_contents(文件地址)
27. 打开一个文件,返回文件资源
              函数:fopen(文件地址,打开模式)
              打开模式:
                      r          只读,指针默认指向开头,如果文件不存在,则报错
                      w         只写,指针默认指向开头,如果文件不存在,则自动创建,如果文件存在,则先将文件截为零,再写入内容
                     a          追加,指针默认指向最后,如果文件不存在,则自动创建
                     \+          增强,配合r,w,a,让它们同时具有读写功能 
28. 读取文件资源
              函数:fread(资源,字节)
29. 写入文件资源
              fwrite(资源,内容)
30. 关闭一个文件资源
              函数:fclose(资源)

### 文件加载:include

格式:include  '文件地址' 或者include('文件地址');

注意:

* include是什么时候执行,就什么时候加载
* include可以重复加载,通过include_once来避免重复加载
* include的加载路径支持相对路径,盘符路径,不支持网络路径和性对路径
* (重点)include如果加载文件失败,不会终止程序

### 文件依赖:require

格式:require  '文件地址' 或者require('文件地址')

- require是什么时候执行,就什么时候加载
- require可以重复加载,通过include_once来避免重复加载
- require的加载路径支持相对路径,盘符路径,不支持网络路径和性对路径
- (重点)require如果加载文件失败,会终止程序

### 文件上传

php通过$_FILES来接收上传文件

接收的是一个数组类型
	array

​		file表单的name值
​		'photo'   =>
​					array
​						上传的文件名		'name' => 
​						上传的文件类型	'type'    =>
​						文件的临时地址	'tmp_name'   =>
​						错误号,0表示成功	'error'    =>
​						上传文件的大小	'size'     => 

上传文件的条件限制
		前端限制:  name="MAX_FILE_SIZE"  content = "自定义大小,单位B"
		协议限制:  php.ini配置文件	配置:post_max_size =  8M
		服务器限制: php.ini配置文件  配置:upload_max_filesize = 2M

上传文件分成六大步

 	1. 检测error
 	2. 检测post协议,通过函数is_uploaded_file(临时文件),来检测
 	3. 检测文件类型
 	4. 设置新的文件名  uniqid()    基于微妙产生一个唯一id,适用于小频率
 	5. 设置新的存储目录
 	6. 移动临时文件 通过函数:move_uploaded_file(临时文件,指定的目录)'000

### 下载文件

1.接收参数

name=$_GET[name]

2.拼接下载路径

3.准备下载后的文件名

header('content-Disposition:attachment;filename=文件名');

4.读取文件下载路径

readfile($path);

## 面向对象

### 面向对象与面向过程的区别

面向过程：以过程为中心的编程思想，先分析出解决问题的步骤，在一步一步的实现，数据和对数据的操作是分离的，执行效率高，但是不易维护，不易复用和不易扩展。

面向对象：将事务对象化，通过对象来解决问题，数据和对数据的操作是绑定在一起的，具有封装，继承，多态性等性能，使系统更加灵活，易维护，易复用，易扩展
	封装：把客观事务封装成抽象的类，隐藏属性和方法的实现细节，仅对外公开接口
	继承：子类可以使用父类的所有功能，并且对这些功能进行扩展，继承的过程就是从一般到特殊的过程
	多态：接口的多种不同的实现方式即为多态，同一操作作用于不同的对象，产生不同的执行效果，在运行时，通过指向基类的指针或引用来调用派生类中的虚函数来实现多态。
	封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的类。它们的目的都是为了代码重用，而多态则是为了实现另一个目的的接口重用。

### 面向对象思想：OOP

概念：
	类：虚
	对象：实

关系：
	类，就是对象的抽象化
	对象：就是类的实例化

一切皆对象

### 定义类

​	class  类名
​	{
​		成员属性   
​		成员方法
​	}

### 实例化对象

​	变量 = new  类名

### 通过对象来使用属性

​	格式： 对象->方法名()

每一次实例化，都会重新生成一个对象（哪怕实例化同一个类，得到的都不是同一个内存）

类内是可以实例化自己的，在类内通过$this来代替实例化自己，$this代表当前自己的对象

在一个类中，方法a想要使用方法b的局部变量，只需要在方法b中，将局部变量变成属性即可

类内属性的创建
	$this -> 新的属性名 = 属性值

### 连贯操作

​	格式：对象 -> 方法一() -> 方法二（）  -> 方法三（）  ->...
​	注意：前面的方法必须要返回能调用后面方法的对象才行

### 魔术方法

1. 构造方法
   格式：修饰符	      function       __construct()

   ​	作用：初始化
   ​	触发条件：实例化对象时
   ​	位置：属性的后面，方法的前面
   ​	返回值：不需要返回值

2. 析构方法
          格式：   修饰符         function       __destruction()
          作用：当前对象结束时，做的结尾操作
          触发条件：当对象被销毁时，自动触发
          常见的3中销毁场景：
                                              \* 程序自然结束时
                                              *对象变量被主动删除时
                                              *对象变量被覆盖时

3. __get()

      ​	当访问非公有的属性时，自动触发

4. __set()

      ​	当设置非公有属性时，自动刚出发

5. __unset()

      ​	当删除非公有属性时，自动触发

6. __isset()

      ​	当检测非公有属性是否设置(为空)时，自动触发

7. __call()

      ​	当访问不存在的方法时，自动触发

8. __toString()

      ​	当输出对象时，自动触发，且必须要返回字符串值

9. __callStatic()

      ​	当访问一个不存在的静态方法时，自动触发
      ​	本身就是一个静态方法

10. __clone()

      ​	当克隆对象时，自动触发，常用于防止别人克隆

11. __sleep()

       ​	串行化时，自动触发，可以隐藏部分属性

12. __wakeup()

       ​	反串行化时自动触发，在唤醒时可以重新初始化属性

### 封装

高内聚：将对象的全部成员属性和方法集中在一个类里面

低耦合：尽可能隐藏成员属性和方法，只留下部分接口与外部联系

|  修饰符   | 类外 | 类内 | 子类 |
| :-------: | :--: | :--: | :--: |
|  public   |  √   |  √   |  √   |
|  private  |  ×   |  √   |  ×   |
| protected |  ×   |  √   |  √   |

修饰符等级排序：private  >  protected  >  public

### 继承

定义：子类继承父类的属性or方法

格式：
	class   子类     extend    父类
	{

​	}

父类又名：基类，基础类

子类又名：继承类，扩展类，派生类

特性：

* 可继承属性，方法（私有属性和方法不能继承）
* 可重写/扩展属性、方法
* 在继承时，修饰符要么保留等级要么降级
* 一个子类只能继承一个父类，一个父类可以被多个子类继承

使用场景：

​		有多个类需要使用多个相同的功能时，多个相同的功能集中在父类中

### 静态类

格式：
	static    修饰符      属性名
	修饰符  static        属性名
	修饰符   static	属性名=属性值

操作：

​	类名::属性名
​	类名::方法名()

特性

 * 可以修饰成员属性，方法
 * 静态不需要对象就可以直接使用
 * 在静态方法内，只能使用静态属性or方法
 * 静态可以继承

### 类常量

格式：
	const  类常量名  =  常量值

特性：

* 类常量既不是属性，也不是方法
* 类常量可以继承，且重写一次常量
* 在一个类中，只能存在一个同名的常量

操作 ：

​	类名::常量名

### 最终类

格式：
	final     class    类名
	{}

特性：

* 修饰类，被称之为“最终类”，不能被继承
* 修饰方法，被称之为“最终方法”，不能被重写

作用：保护父类结构

### 抽象

格式：

​	abstract         class        类名{}

​	abstract		修饰符	function     方法名(){}

特性：

* 修饰类，被称之为“抽象类”
* 修饰方法，被称之为“抽象方法”
* 没有方法体的方法被称之为抽象方法

作用：约束子类

含有方法的类必须是抽象类，抽象类不一定要有抽象方法

### 接口

定义：当抽象类全部为抽象方法时，即可用接口

格式：

​	interface      接口类名
​	{
​	}

class     子类     implements       接口类{}

class     子类   implements	     接口类1，接口类2，接口类3，。。。{}

### 克隆运算符

格式：
	对象2 = clone   对象1

特性：

* 对象1和对象2完全相同，互不影响，内存独立

### instanceof运算符

检测是否是从 某类实例化过来的

检测是否是从某类继承过来的

格式：

​	对象A   instanceof    对象B

​	对象A   instanceof   类名

### 串行化/序列化

作用：将对象转化为字符串，为了可以实现页面传输，存入数据库，存入文本等

函数：
	serialize()   串行化，将对象转化为字符串

​	unserialize()   	反串行化，将字符串转化为对象

### 自动加载

触发条件：当实例化一个不存在的类时，自动触发

好处：当需要实例化多个不同的类时，且类不在当前页面中，可通过“自动加载”按需加载相关的类文件	

项目规则：

* 一个文件只能含有一个类
* 类名与类文件必须有关联
* 类名与类名文件使用大驼峰命名法

格式：

php7之前的版本

```php
function    __autoload($x)
{

	if( file_exists( "./Lib/{$x}.php" ) ){
       		include_once "./Lib/{$x}.php";
     	}else{
       		 header('location: ./404/index.html');
         	die;	
	}

}
```

php7的版本

```
function load( $x )
{
    if( file_exists( "./Lib/{$x}.php" ) ){
        include_once "./Lib/{$x}.php";
    }else{
        header('location: ./404/index.html');
        die;
    }
}
spl_autoload_register('load');
```

### 多态

通过同一个接口类，传入不同的对象，从而实现不同的效果

### 常用函数

class_exists()		检测类是否存在

property_exists()	检测属性是否存在

get_class_vars()	获取类中的属性

get_object_vars()	获取对象中的属性

get_class_methods()	获取类中的所有方法

get_calss()	获取对象中的类

### 异常结构

语法：

​	try{
​			捕获异常：
​				1.自动：违反PHP解释器规则
​				2.主动：违反人为逻辑设定
​						主动抛出异常：
​								throw	 new  Exception('错误信息')

​		}catch （Exception $e){

​			处理异常
​				$e->getMessage() 	获取错误信息
​				$e->getFile()			获取错误文件
​				$e->getLine()			获取错误行号
​				$e->getCode()		获取错误编号

​		}

​	运行方式：
​		现在捕获区域捕获异常，一旦捕获到则立马跳转至catch进行处理

### 设计模式

#### 单例模式

​	定义：保证只有一个实例

​	特性：
​		1.只有一个实例
​		2.自己创建自己
​		3.必须要返回实例，供给别人使用

### PDO

#### PDO的构造方法：

​	__constuct($sdn,$user,$password)
​		$sdn：选择哪种数据库类型，主机名，要选择的数据库，字符编码
​		$user：数据库用户名
​		$password：数据库密码

​		$sdn = 'mysql:host=localhost;dbname=wjh;charset=utf8'

#### 执行sql：

​	PDO::query()		执行一条sql语句，擅长于查询，返回一个结果集

​	PDO::exec()		执行一条语句，擅长于增删改，返回后影响的行数

​	PDO::lastinsertId()	获取最有一次插入的id

​	PDO::errorinfo()		获取最后一次的sql错误信息

#### 结果集：PDOstatement

​	PDOstatement::fetch()	丛结果集中获取一条数据（一维数组）

​	PDOstatement::fetchAll()	从结果集中获取所有数据（二维数组）

#### 事务

​	1.定义：将多条sql语法绑定为一个整体，只有全部成功才算成，其中只要有任意一条sql出错，则整体出错

​	2.事务支持：
​		

| #        | MyISAM                                                       | InnoDB                                               |
| -------- | ------------------------------------------------------------ | ---------------------------------------------------- |
| 事务     | 不支持                                                       | 支持                                                 |
| 外键     | 不支持                                                       | 支持                                                 |
| 全文索引 | 支持                                                         | 不支持，但是可以用sphinx代替                         |
| 表总行数 | 储存<br />count(字段名)可以直接获取<br />count() 若带where条件，则会遍历整表，消耗巨大 | 为储存<br />当场遍历整表，消耗巨大                   |
| CURD     | 擅长查询数据                                                 | 擅长增删改                                           |
| 行表锁   | 表锁<br />开销小，加锁快，低并发                             | 行锁(默认)，表锁<br />开销大，加锁满，易锁死，高并发 |

​	3.自动提交

​			Mysql默认情况，都是开启自动提交(一旦执行sql语句，数据库就立即响应)

​			事务一般都会提前关闭自动提交

​			什么时候开启自动提交
​				1.当事务结束时
​				2.当事务执行成功时，会主动提交sql

​	4.操作事务

​		1.关闭自动提交

​			setAttribute(pdo::ATTR_COMMIT,0)
​		2.开启一个事务

​			beginTransAction()

​		3.正常操作sql业务
​			成功：主动提交事务

​				commit()

​			失败：回滚事务

​				rollback()

​		4.开启自动提交

​			setAttribute()

## 会话控制

### cookie

1. 设置/添加cookie
           setcookie(Cookie名, Cookie值, 生命周期, 有效路径, 有效域名)

2. 删除cookie

   ​	setcookie('cookie名','cookie值'，time()-1)

3. 查看cookie

   ​	var_dump($_COOKIE);

   ###  session

   * 默认情况下，session是关闭的，需要先通过session_start()来开启session
   * 任意PHP文件只要使用session_start()开启就可以使用session里面任意的数据
   * 作用域：整个服务器

   1. 开启session

      ​	session_start();

   2. 查看session

      ​	var_dump($_SESSION)

   3. 删除session

      ​	unset($_SESSION['name'])

   

